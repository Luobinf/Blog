
## git clone
可以将远程仓库获取到本地，获取到文件后，在你进入之后会发现有一个叫做 **.git** 的隐藏目录。
这个**.git**目录，就是你的**本地仓库（Local Repository）**，你的**所有版本信息**都会存在这里。**.git**目录所在的
目录也成为Git的**工作目录（Working Directory）**

## git log用于查看你的提交历史

## git status -sb
用于查看Git工作目录的状态，是否添加到了**Git的暂存区**，即**.git**目录下的**index**文件。

## git add
该命令用于Git开始追踪文件。当文件属于 "untracked" 状态，它的意思是 Git 仓库对它没有进行任何记录，
你在提交的时候不会把它提交上去，查看提交历史也不会看到它。总之，对于 Git 仓库来说，它是不存在的。
使用 git add 命令可以将文件添加到**Git工作目录下的暂存区**，使得 Git 开始跟踪他。


## git ommit
该命令将添加到**暂存区的文件**提交到本地仓库，被保存在了 .git 这个目录里的某个地方了。


## git push
使用了 git ommit 命令之后，它们都还在本地仓库。该命令是将本地仓库的文件提交上传到远程仓库。

## git pull
将远程仓库的代码拉取下来更新本地仓库。

## 多人合作的基本模型
1. 同事 commit 代码到他的本地仓库，并 push 到 GitHub 中央仓库
2. 你把 GitHub 的新提交通过 pull 指令来取到你的本地仓库

通过这个流程，你和同事就可以简单地合作了：你写了代码，commit，push 到 GitHub，然后他 pull 到他的本地；他再写代码，commit, push 到 GitHub，然后你再 pull 到你的本地。

但是，这种合作有一个严重的问题：同一时间内，只能有一个人在工作。你和同事其中一个人写代码的时候，另一个人不能做事，必须等着他把工作做完，代码 push 到 GitHub 以后，自己才能把 push 上去的代码 pull 到自己的本地。而如果同时做事，就会发生冲突：当一个人先于另一个人 push 代码（这种情况必然会发生），那么后 push 的这个人就会由于中央仓库上含有本地没有的提交而导致 push 失败。

```JavaScript
为什么会失败？
因为 Git 的push 其实是用本地仓库的 commits 记录去覆盖远端仓库的 commits 记录（注：这是简化概念后的说法，push 的实质和这个说法略有不同），而如果在远端仓库含有本地没有的 commits 的时候，push （如果成功）将会导致远端的 commits 被擦掉。这种结果当然是不可行的，因此 Git 会在 push 的时候进行检查，如果出现这样的情况，push 就会失败。
```
如何解决?

## push发生冲突
在现实的团队开发中，全队是同时并行开发的，所以必然会出现当一人 push 代码时，中央仓库已经被其他同事先一步 push 了的情况。

团队协作时，当有一个同时做了一个commit来提交，然后你有commit了一次，这时候你想要push到远程仓库，就会出现如下冲突。
![3OjmWT.png](https://s2.ax1x.com/2020/03/07/3OjmWT.png)

由于 GitHub 的远端仓库上含有本地仓库没有的内容，所以这次 push 被拒绝了。这种冲突的解决方式其实很简单：**先用 pull 把远端仓库上的新内容取回到本地和本地合并，然后再把合并后的本地仓库向远端仓库推送**

使用 git pull 将远端仓库上的新内容取回到本地，这时候会出现如下页面。
![3Ov2U1.png](https://s2.ax1x.com/2020/03/07/3Ov2U1.png)

为什么会出现这样一个界面?
这是因为当 pull 操作发现不仅远端仓库包含本地没有的 commit，而且本地仓库也包含远端没有的 commit 时，它就会把远端和本地的独有 commit 进行合并，自动生成一个新的 commit ，而上图的这个界面，就是这个自动生成的 commit 的提交信息界面。另外，和手动的 commit 不同，这种 commit 会自动填入一个默认的提交信息，简单说明了这条 commit 的来由。你可以直接退出界面来使用这个自动填写的提交信息，也可以修改它来填入自己提交信息。

**这种「把不同的内容进行合并，生成新的提交」的操作，叫做合并。它所对应的 Git 指令是 merge。事实上，git pull 这个指令的内部实现就是把远程仓库使用 git fetch 取下来以后再进行 merge 操作的**


在退出提交信息的界面后，这次 pull 就完成了：远端仓库被取到了本地，并和本地仓库进行了合并。在这个时候，就可以再 push 一次了。由于现在本地仓库已经包含了所有远端仓库的 commits，所以这次 push 不会再失败：
![3OxQaR.png](https://s2.ax1x.com/2020/03/07/3OxQaR.png)

以上方法就能解决push时本地仓库和远端仓库内容冲突。

## HEAD、master、branch
这一部分内容需要详细说说，之后会再次补充。

1. 创建**branch**的方法是 **git branch 名称**
2. 切换**branch**的方法是 **git checkout 名称**，本质上是将 HEAD 指向了当前 branch ，然后再指向当前 branch 的最新 commit
3. 删除的方式是 **git branch -d 名称**

## push的本质：将branch上传到远程仓库
实质上，push 做的事是：把当前 branch 的位置（即它指向那个 commit）上传到远程仓库，并把它的路径上的 commits 一并上传。
push 并不会上传本地的 HEAD 指向；远程仓库的 HEAD 是永远指向默认分支（即 master）

## merge：合并commits
merge 的意思是「合并」，它做的事也是合并：指定一个 commit，把它合并到当前的 commit 来。具体来讲，merge 做的事是：
**从目标 commit 和当前 commit （即 HEAD 所指向的 commit）分叉的位置起，把目标 commit 的路径上的所有 commit 的内容一并应用到当前 commit，然后自动生成一个新的 commit。**

如下图：
![3X6BMF.png](https://s2.ax1x.com/2020/03/07/3X6BMF.png)

HEAD 指向了 master，所以如果这时执行：
```
git merge branch1
```
Git 会把 5 和 6 这两个 commit 的内容一并应用到 4 上，然后生成一个新的提交，并跳转到提交信息填写的界面：

merge 操作会帮你自动地填写简要的提交信息。在提交信息修改完成后（或者你打算不修改默认的提交信息），就可以退出这个界面，然后这次 merge 就算完成了。

![3X6WRK.png](https://s2.ax1x.com/2020/03/07/3X6WRK.png)

merge 有什么用？最常用的场景有两处：
1. 合并分支
当一个 branch 的开发已经完成，需要把内容合并回去时，用 merge 来进行合并
2. pull 的内部操作
pull 的实际操作其实是把远端仓库的内容用 fetch 取下来之后，用 merge 来合并。





